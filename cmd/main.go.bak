package main

import (
	"context"
	"database/sql"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	_ "github.com/lib/pq"

	"market_order/api"
	"market_order/application/notification"
	"market_order/application/saga"
	"market_order/application/usecases"
	"market_order/infrastructure/eventstore"
	"market_order/infrastructure/idempotency"
	"market_order/infrastructure/messaging"
	"market_order/infrastructure/outbox"
	"market_order/infrastructure/repository"
)

func main() {
	log.Println("üöÄ Starting Market Order Service...")

	// =====================================================
	// 1. Database Connection
	// =====================================================
	dbURL := getEnv("DATABASE_URL", "postgres://postgres:postgres@localhost:5432/eventstore?sslmode=disable")
	db, err := sql.Open("postgres", dbURL)
	if err != nil {
		log.Fatalf("‚ùå Failed to connect to database: %v", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		log.Fatalf("‚ùå Database ping failed: %v", err)
	}
	log.Println("‚úÖ Connected to PostgreSQL")

	// =====================================================
	// 2. Infrastructure Layer
	// =====================================================
	
	// Event Store
	es := eventstore.NewPostgresEventStore(db)
	log.Println("‚úÖ Event Store initialized")

	// RabbitMQ
	rabbitURL := getEnv("RABBITMQ_URL", "amqp://guest:guest@localhost:5672/")
	mb := messaging.NewRabbitMQ(rabbitURL)
	if err := mb.Connect(); err != nil {
		log.Fatalf("‚ùå Failed to connect to RabbitMQ: %v", err)
	}
	defer mb.Close()

	// Idempotency
	processedEventsRepo := idempotency.NewProcessedEventsRepository(db)
	log.Println("‚úÖ Idempotency repository initialized")

	// =====================================================
	// 3. Repositories
	// =====================================================
	orderRepo := repository.NewOrderRepository(es)
	positionRepo := repository.NewPositionRepository(es)
	log.Println("‚úÖ Repositories initialized")

	// =====================================================
	// 4. Use Cases
	// =====================================================
	createOrderUC := usecases.NewCreateOrderUseCase(orderRepo)
	completeOrderAndPosUC := usecases.NewCompleteOrderAndUpdatePositionUseCase(
		orderRepo,
		positionRepo,
		es, // Pass event store for atomic transaction
	)
	log.Println("‚úÖ Use cases initialized")

	// =====================================================
	// 5. External Services (Mock for demo)
	// =====================================================
	priceService := &MockPriceService{}
	tradeWorker := &MockTradeWorker{}
	notifier := &notification.MockNotifier{}
	log.Println("‚úÖ External services initialized (mock)")

	// =====================================================
	// 6. Saga Orchestrator
	// =====================================================
	orderSaga := saga.NewOrderSaga(
		orderRepo,
		positionRepo,
		processedEventsRepo,
		createOrderUC,
		completeOrderAndPosUC,
		mb,
		priceService,
		tradeWorker,
	)
	log.Println("‚úÖ Saga orchestrator initialized")

	// =====================================================
	// 7. Notification Service
	// =====================================================
	notificationService := notification.NewNotificationService(
		orderRepo,
		positionRepo,
		processedEventsRepo,
		mb,
		notifier,
	)
	log.Println("‚úÖ Notification service initialized")

	// =====================================================
	// 8. Outbox Publisher (Transactional Outbox Pattern)
	// =====================================================
	outboxPub := outbox.NewOutboxPublisher(db, mb)
	log.Println("‚úÖ Outbox publisher initialized")

	// =====================================================
	// 9. API Server
	// =====================================================
	orderHandler := api.NewOrderHandler(createOrderUC)
	
	mux := http.NewServeMux()
	mux.HandleFunc("/health", api.HealthCheck)
	mux.HandleFunc("/orders", orderHandler.CreateOrder)

	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	log.Println("‚úÖ HTTP server configured on :8080")

	// =====================================================
	// 10. Start Background Workers
	// =====================================================
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Start Outbox Publisher (publishes events to RabbitMQ)
	go func() {
		log.Println("üîÑ Starting Outbox Publisher...")
		if err := outboxPub.Start(ctx); err != nil {
			log.Printf("‚ùå Outbox publisher error: %v", err)
		}
	}()

	// Start Saga Orchestrator (listens to OrderAccepted events)
	go func() {
		log.Println("üîÑ Starting Saga Orchestrator...")
		if err := orderSaga.Start(ctx); err != nil {
			log.Printf("‚ùå Saga orchestrator error: %v", err)
		}
	}()

	// Start Notification Service (listens to OrderCompleted/OrderFailed events)
	go func() {
		log.Println("üîÑ Starting Notification Service...")
		if err := notificationService.Start(ctx); err != nil {
			log.Printf("‚ùå Notification service error: %v", err)
		}
	}()

	// Start HTTP Server
	go func() {
		log.Println("üåê Starting HTTP server on :8080...")
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("‚ùå HTTP server error: %v", err)
		}
	}()

	// =====================================================
	// 11. Graceful Shutdown
	// =====================================================
	log.Println("‚úÖ All services started successfully!")
	log.Println("üì° Listening for orders on http://localhost:8080/orders")
	log.Println("Press Ctrl+C to shutdown...")

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	<-sigChan
	log.Println("\nüõë Shutting down gracefully...")

	// Shutdown HTTP server
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer shutdownCancel()
	
	if err := server.Shutdown(shutdownCtx); err != nil {
		log.Printf("‚ùå HTTP server shutdown error: %v", err)
	}

	// Cancel background workers
	cancel()

	log.Println("üëã Goodbye!")
}

// =====================================================
// Mock Implementations (for demo purposes)
// =====================================================

type MockPriceService struct{}

func (m *MockPriceService) GetMarketPrice(ctx context.Context, from, to string) (float64, error) {
	// Simulate price service
	log.Printf("üí∞ [MockPriceService] Getting price for %s/%s", from, to)
	
	// Simulate prices
	if from == "USDT" && to == "BTC" {
		return 100000.0, nil // 1 BTC = 100k USDT
	}
	if from == "USDT" && to == "ETH" {
		return 4000.0, nil // 1 ETH = 4k USDT
	}
	
	return 1.0, nil // Default
}

type MockTradeWorker struct{}

func (m *MockTradeWorker) ExecuteSwap(ctx context.Context, req saga.SwapRequest) (*saga.SwapResponse, error) {
	// Simulate swap execution
	log.Printf("üîÑ [MockTradeWorker] Executing swap: %.2f %s -> %s (idempotency: %s)",
		req.FromAmount, req.FromCurrency, req.ToCurrency, req.IdempotencyKey)
	
	// Simulate network delay
	time.Sleep(100 * time.Millisecond)
	
	// Calculate toAmount based on mock prices
	var price float64
	if req.FromCurrency == "USDT" && req.ToCurrency == "BTC" {
		price = 100000.0
	} else if req.FromCurrency == "USDT" && req.ToCurrency == "ETH" {
		price = 4000.0
	} else {
		price = 1.0
	}
	
	toAmount := req.FromAmount / price
	
	return &saga.SwapResponse{
		TransactionHash: "0xabc123def456789...",
		ToAmount:        toAmount,
		ExecutedPrice:   price,
		Fees:            0.5,    // 0.5 USDT
		Slippage:        0.02,   // 0.02%
	}, nil
}

// Helper function
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
